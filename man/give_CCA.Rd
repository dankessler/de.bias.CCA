% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/give_CCA.R
\name{give_CCA}
\alias{give_CCA}
\title{De-biased CCA estimators}
\usage{
give_CCA(alpha, beta, X, Y, C, elements, nlC)
}
\arguments{
\item{alpha}{A vector of length p, estimator of \eqn{\alpha}, the  leading canonical vector corresponding to X.}

\item{beta}{A vector of length q, estimator of \eqn{\beta}, the  leading canonical vector corresponding to Y.}

\item{X}{A matrix with n rows and p columns, the first dataset.}

\item{Y}{A matrix with n rows and q columns, the second dataset.}

\item{C}{An optional constant. Default is 2.}

\item{elements}{Optional. A vector of integers taking values in the set {1,2,...,p+q}. Corresponds to variance estimates of
the debiased estimators of  \eqn{\alpha_i} and \eqn{\beta_j}. See details. The default value
  is the vector {1,2,...,p+q}.}

\item{nlC}{An optional  constant. Must be positive. The default is \eqn{\sqrt{\log(p+q)/n}}.}
}
\value{
A list. Contains the followings:
\describe{
\item{matx}{ A data frame with de-biased and initial estimators of \eqn{\alpha}
               in first and second columns, respectively.}
\item{maty}{ A data frame with de-biased and initial estimators of \eqn{\beta}
               in first and second columns, respectively.}
\item{var_calc}{ A (p + q)-length vector with the variance of the parameters
              specified by the \code{elements} argument. Non-specified
              positions return "NA".}
\item{rhosq_db}{ The debiased estimate of the squared first canonical correlation.}
\item{rhosq_var}{ The variance estimate of the debiased squared first canonical correlation.}
}
}
\description{
Suppose X and Y are random vectors with variance \eqn{\Sigma_x} and
\eqn{\Sigma_y},  and cross-covariance matrix \eqn{\Sigma_{xy}}.
 The leading canonical correlation coefficient  is defined as
       \deqn{\rho=\max_{\alpha,\beta}\alpha'\Sigma_{xy}\beta}
       where the maximization is over
         \eqn{\alpha: \alpha'\Sigma_x\alpha=1} and \eqn{\beta: \beta'\Sigma_y\beta=1}.
        The solutions to the above optimization problems are known as
        the canonical directions. If the estimators of \eqn{\alpha} and \eqn{\beta}
        are sparse, then a first order bias is incurred. Laha et al. (2021)
        introduces a bias correction method, which provides  elementwise \eqn{\sqrt{n}}-consistent
        estimators of \eqn{\sqrt{\rho}\alpha} and \eqn{\sqrt{\rho}\beta},
        provided the preliminary estimators of \eqn{\alpha} and \eqn{\beta} satisfy some \eqn{l_1} and \eqn{l_2}
        consistency properties. We also provide a \eqn{\sqrt{n}}-consistent  estimator of
        \eqn{\rho^2}. See Laha et al. (2021) for more details.
The following function provides de-biased estimators of \eqn{\sqrt{\rho}\alpha},
          \eqn{\sqrt{\rho}\beta}, \eqn{\rho^2}, and estimates of their  variances.
}
\details{
\code{elements} The variance estimates corresponding to
               \eqn{\alpha_i} (or \eqn{\beta_j}) are calculated
               only if i (or p+i) are in \code{elements}. Otherwise, NA will be returned.

\code{nlC} The node-wise Lasso parameter \eqn{\lambda^{nl}_j} in Laha et al. (2021).
             Should be a constant multiple of  \eqn{\sqrt{\log(p+q)/n}}.

\code{C} The constant C in Lemma 1 of Laha et al. (2021). The value of 2 has been used in this paper.

\code{nlC}  Penalty parameter for a
               \eqn{l_1} penalty term, required in the nodewise Lasso step,
                         during inversion of the hessian matrix.
}
\examples{
library(mvtnorm)
library(dplyr)
library(CVXR)

#Simulate standard normal data matrix: first generate alpha and beta
p <- 50; q <- 50; al <- c(rep(1, 10), rep(0, 40));
be <- c(rep(0,25), rnorm(25,1))

#Normalize alpha and beta
al <- al/sqrt(sum(al^2)); be <- be/sqrt(sum(be^2))

 #Set n and rho
n <- 300; rho <- 0.5

#Creating the covariance matrix
Sigma_mat <- function(p,q,al,be, rho)
{
 Sx <- diag(rep(1,p), p, p)
 Sy <- diag(rep(1,q), q, q)
 Sxy <- tcrossprod(crossprod(rho*Sx, outer(al, be)), Sy)
 Syx <- t(Sxy)
 rbind(cbind(Sx, Sxy), cbind(Syx, Sy))
}
truesigma <- Sigma_mat(p,q,al,be, rho)

#Finally simulating the data
Z <- mvtnorm::rmvnorm(n, sigma = truesigma)
x <- Z[,1:p]
y <- Z[,(p+1):(p+q)]
elements <- 1:p
nlC <- log(p+q)/n

 # Preliminary estimators: Mai(2019)'s SCCA estimators
temp <- cca.mai(x,y)
ha <- temp[[1]]
hb <- temp[[2]]

#Call give_CCA
give_CCA(ha, hb, x, y)
}
\references{
Laha, N., Huey, N., Coull, B., and Mukherjee, R. (2021). \emph{On Statistical
Inference with High Dimensional Sparse CCA}, submitted.
}
\keyword{cca}
